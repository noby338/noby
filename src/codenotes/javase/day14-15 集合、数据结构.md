---
title: day14-15 集合、数据结构
icon: write
category:
  - JavaSE
tag:
  - JavaSE
sticky: false
star: false
article: true
timeline: true
---
## 集合

### 集合和数组区别

1. 长度：集合可变，数组不可变
2. 数据类型：集合只能是引用类型，数组可以是引用类型和基本数据类型
3. 数据一致性：同一集合可以是不同的引用数据类型，同一数组只能是同一类型

### 各种集合的区别

 * List：值可重复
     * 		ArrayList、Vector：基于数组实现
     * 		LinkedList：基于双向链表实现
 * Set：值不重复
     *  	HashSet：基于HashMap实现
     *  	TreeSet：(存入后按照字典顺序排序，而不是存入顺序)基于TreeMap实现
 * Map：key不可重复
     * 		HashMap：无序、key不重复，基于数组+单链表+红黑树实现的
     * LinkedHashMap：有序(存入顺序)、key不重复，基于数组+单链表+红黑树+双向链表实现的
     * TreeMap：有序(存入后字典排序)、key不重复，基于红黑树实现

### 单列集合

#### Collection接口

![image-20220215093134818](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220215093134818.png)

```java
package note;

import java.util.ArrayList;
import java.util.Collections;

public class CollectionsNote {//collection工具类
    public static void main(String[] args) {
        //region addAll shuffle sort
        ArrayList<String> lis = new ArrayList<>();
        Collections.addAll(lis,"b","a","c","d","e");//添加多个元素
        System.out.println(lis);//[b, a, c]
        Collections.shuffle(lis);//随机打乱
        System.out.println(lis);//[b, c, a]
        Collections.sort(lis);//按照规则排序
        System.out.println(lis);//[a, b, c]
        //endregion
    }
}

```

##### list接口

1. 元素有序
2. 元素可重复
3. 有索引
4. 两个接口的区别：
   * ArrayList基于数组实现，ArrayList遍历快（数组空间连续的），ArrayList增删慢（需要移动数据）
   * LinkedList基于双向链表实现，LinkedList遍历慢（数据分散在内存各个地方），LinkedList增删快（只需要改变指向）

###### ArrrayList实现类

* 增删慢，查询快

```java
package note;

import java.util.*;
import java.util.function.Predicate;

public class ArrayListNote {
    public static void main(String[] args) {
        //region 创建
        ArrayList<String> strings = new ArrayList<>();
        ArrayList<String> strings1 = new ArrayList<>();
        //endregion

        //region 成员方法
        strings.add("str1");//添加
        strings.add("str2");
        strings.add("str3");
        strings.add("str4");
        strings.addAll(strings1);//将其他集合的全部元素加入到该集合
        Collections.addAll(strings, "java", "hello", "learn");//通过Collections集合工具类添加所有元素

        String s = strings.get(1);//获取元素

        int size = strings.size();//获取长度

        strings.remove(1);//删除指定索引的元素(仅当该集合有索引值时可用)
        strings.remove(new Integer(1));//表示删除内容为1的元素
        strings.remove("str1");//删除指定内容
        strings.removeAll(strings1);//将该集合其他集合的全部元素删除
        strings.removeIf(new Predicate<String>() {//遍历删除内容,底层调用的迭代器
            @Override
            public boolean test(String s) {
                return s.contains("str");
            }
        });

        strings.clear();//清空集合
        strings.isEmpty();//是否为空

        System.out.println(strings);//直接查看元素内容
        //endregion

        //region 遍历集合
        //region Iterator迭代器 遍历集合
        Iterator<String> iterator = strings.iterator();
        while (iterator.hasNext()) {
            String next = iterator.next();//获取当前元素后，将指针指向下一个元素
            if (next.equals("something")) {
                iterator.remove();//通过迭代器删除元素
            }
        }
        //endregion

        //region 增强for循环
        for (String string : strings) {
            System.out.println(string);
        }
        //endregion

        //region 通过转换为数组遍历
        Object[] objects = strings.toArray();
        for (Object object : objects) {
            System.out.println(object);
        }
        //endregion
        //endregion

        //region sort ArrayLi的排序
        strings.sort(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.compareTo(o2);
            }
        });
        //endregion
    }
}

```

###### LinkedList实现类

```java
package note;

import java.util.LinkedList;

public class LinkedListNote {
    public static void main(String[] args) {
        //region 创建
        LinkedList<Integer> integers = new LinkedList<>();
        integers.add(1);
        integers.add(2);
        integers.add(3);
        integers.add(4);
        integers.add(5);
        System.out.println(integers);
        //endregion

        //region remove
        integers.removeFirst();//删除第一个元素
        integers.removeLast();//删除最后一个元素

        integers.remove(2);//删除第二个元素(list集合都带有索引)
        integers.remove(new Integer(2));//删除内容为2的元素
        //endregion

        integers.clear();
        integers.add(0);
        integers.add(0);
        integers.add(0);
        integers.add(0);

        //region addfirst()
        integers.addFirst(1);//添加到第一个元素
        integers.addLast(2);//添加到最后一个元素

        System.out.println(integers);
        //endregion
    }
}
```

###### Vector实现类

* 过期，底层数据结构同ArrayList为数组

```java
package note;

import java.util.Collections;
import java.util.Enumeration;
import java.util.Vector;

public class VectorNote {//向量
    public static void main(String[] args) {
        Vector<Integer> integers = new Vector<>();
        Collections.addAll(integers,1,2,3,4,5);

        //region Vector通过枚举器遍历
        /*
        迭代器存在安全问题,不推荐
         */
        /*
         * 快速失败：就是在原有的数据结构上进行遍历,当某个程序修改了原有的数据结构，如果当前程序继续遍历结构会快速失败（不允许继续遍历）
         *     迭代器：快速失败
         *
         * 安全失败：在副本（克隆、备份）上进行遍历,即使另一个程序修改原有的数据结构也会不影响到当前程序的遍历
         *     枚举器：安全失败
         *
         * ArrayList：无参构造得到的数据长度为0，第一次放数据时才会创建长度为10的数组
         *           ArrayList默认扩容为原来的1.5倍
         * Vector：默认长度就是10
         *           Vector默认扩容为原来的2倍
         */

        Enumeration<Integer> elements = integers.elements();
        while (elements.hasMoreElements()) {
            System.out.println(elements.nextElement());
        }
        //endregion
    }
}
```

##### set接口

* 无序的(存入和取出的顺序不一致)
* 元素唯一的
* 无索引

###### HashSet实现类

```java
package note;

import java.util.Collections;
import java.util.HashSet;

public class HashSetNote {
    public static void main(String[] args) {
        /*
        底层通过HashMap实现
         */
        //region 创建
        HashSet<String> strings = new HashSet<>();
        //endregion

        //region 相对于list集合有区别的成员方法
        Collections.addAll(strings,"张三","李四","王五","赵六");
        System.out.println(strings.add("张三"));//添加失败，set集合不能存储相同的元素
        System.out.println(strings);//打印出的元素是无序的
        //endregion
    }
}
```

###### TreeSet实现类

* 相对于HashSet可排序(根据字符串字典顺序)(自然顺序排序)

  ```java
  package note;
  
  import java.util.Collections;
  import java.util.TreeSet;
  
  public class TreeSetNote {
      public static void main(String[] args) {
          /*
           * TreeSet基于红黑树实现的 TreeMap（平衡二叉树-排序二叉树-红黑树）
           * TreeSet里面的数据是有序的
           */
          //region 构造
          TreeSet<String> strings = new TreeSet<>();
          //endregion
  
          //region 相对于HashSet的不同
          Collections.addAll(strings,"java","hello","world");
          System.out.println("strings = " + strings);//相对于HashSet，该集合有序(按照字典排序，而非存入顺序)
          //endregion
  
      }
  }
  ```
  

###### LinkedHashSet实现类

* 相对于HashSet可排序(存入顺序)

  ```java
  package note;
  
  import java.util.LinkedHashSet;
  
  public class LinkedHashSetNote {
      public static void main(String[] args) {
          LinkedHashSet<String> strings = new LinkedHashSet<>();
          strings.add("aaa");
          strings.add("ccc");
          strings.add("ddd");
          strings.add("bbb");
          System.out.println("strings = " + strings);
          //strings = [aaa, ccc, ddd, bbb]
      }
  }
  ```

### 双列集合

#### Map接口

<img src="https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220215093145557.png" alt="image-20220215093145557"  />

##### HashMap实现类

```java
package note;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class HashMapNote {
    public static void main(String[] args) {
        /*
         * HashMap：哈希映射，里面一个数据包个两个非常数据 ： key（键） value（值）
         * 因此称Map是由多个键值对构成的
         *
         * 特点：无序、key不重复
         *
         * 操作Map其实就是操作key
         */

        //region 构造方法
        HashMap<String, Object> noby = new HashMap<>();
        //endregion

        //region 成员方法
        noby.put("name","noby");//添加元素
        noby.put("age",20);//此处传入的是Integer而非int，20将会自动装箱为Integer
        noby.put("isMan",true);
        noby.put("hoby","learn java");

        noby.put("age",21);//当存在该键时，put方法为修改值

        System.out.println(noby.get("name"));//获取值

        System.out.println(noby.size());//获取键值对长度

        noby.remove("hoby");//删除键值对

        System.out.println(noby.containsKey("hoby"));//是否包含该键

        //endregion

        //region 通过keySet集合遍历
        Set<String> keys = noby.keySet();
        Iterator<String> iterator = keys.iterator();
        while (iterator.hasNext()) {
            String next = iterator.next();
            System.out.println(next + " = " + noby.get(next));
        }
        //endregion

        //region 通过entrySet集合遍历
        Set<Map.Entry<String, Object>> entries = noby.entrySet();
        Iterator<Map.Entry<String, Object>> iterator1 = entries.iterator();
        while (iterator1.hasNext()) {
            Map.Entry<String, Object> next = iterator1.next();
            System.out.println(next.getKey() + "-" + next.getValue());
        }
        //endregion
        /*
         * HashMap数组默认长度是16，加载因子是0.75，数组长度*0.75 = 得到该数组中有几个位置可以用来存储数据
         *
         * 放数据的流程：
         *     在放数据时会计算key的hash值，用哈希值与 hashCode() ^ h >>> 16，得到一个数字“哈希值”，假设Map
         *  为空（table = null）会先创建一个数组，默认长度为16，然后将扩容触发条件设置为12（16*0.75），接下来
         *  用“哈希值”与15进行按位与得到一个下标，得到数据应该放在数组中的那个位置，如果该位置没有放任何数据，
         *  就创建Node节点直接将新的节点放在这个位置，否则就用当前新数据的“hash”值与该位置数据的“hash”值进行比较，并且
         *  比较当前新的key与该位置的key是否一样，如果一样则替换原来的数据，否则新数据放在原数据的下边形成链表
         *
         *  当链表的长度达到8的时候，就需要将链表转换成红黑树了（提升查询效率）
         *  当红黑树中的节点小于等于6时需要将红黑树转换链表（降低维护的成本）
         *  什么时候需要将链表转换成红黑树：容量必须大于等于64、并且链表的长度大于等于8
         *
         *  扩容时机：当HashMap中的数据个数大于12个时就需要进行扩容了，扩容原来的2倍，触发时机也会变为原来的2倍，
         *  意思就说下一次扩容会在元素个数超过12*2时。
         *  总结：当HashMap中的数据个数达到数组长度*0.75时进行扩容，扩容为原来的两倍
         *  扩容之后：会将之前的数据重新定位放到新数组的各个地方（拆分链表）
         *
         */

    }
}
```

##### treeMap实现类

```java
package note;

import java.util.HashMap;
import java.util.TreeMap;

public class TreeMapNote {
    public static void main(String[] args) {
        //region 构造
        TreeMap<String, Object> kace = new TreeMap<>();
        //endregion

        //region 成员方法
        kace.put("ccc",22);
        kace.put("aaa","kace");
        kace.put("bbb","man");

        /*
        TreeMap集合有序:并不是对存入的顺序进行排序，而是通过一定的规则排序
        LInkedHashMap集合有序：对存入的顺序进行排序
         */
        //endregion

        System.out.println(kace);//{aaa=kace, bbb=man, ccc=22}
    }
}
```

##### LinkedHashMap实现类

```java
package note;

import java.util.LinkedHashMap;

public class LinkedHashMapNote {
    public static void main(String[] args) {
        LinkedHashMap<String, Object> noby = new LinkedHashMap<>();
        noby.put("name","noby");
        noby.put("age",21);
        noby.put("gender","man");

        System.out.println(noby);//{name=noby, age=21, gender=man}
        /*
        LinkedHashMap对存入的顺序进行排序
         */
    }
}
```

###### Properties实现类

```java
package Demo;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.Properties;
import java.util.Set;

public class PropertiesDemo {
    public static void main(String[] args) throws Exception{
        //配置文件以.properties为后缀
        Properties properties = new Properties();//属于Map集合

        //region properties集合的特有方法
        properties.setProperty("one","hello");//若用setProperty()方法，键和值都只能存储字符串。Map中的put()方法键和值可以为任意类型
        properties.setProperty("two","world");
        properties.setProperty("three","java");

        System.out.println(properties.getProperty("one"));//相当于Map()中的get()方法

        Set<String> strings = properties.stringPropertyNames();//相当于Map中的keySet()方法
        System.out.println(strings);
        //endregion

        //region 将properties存储到配置文件
        FileOutputStream fos = new FileOutputStream("D:\\IdeaProjects\\JavaPra\\day23\\src\\Demo\\str\\SropertiesStore.properties");
        properties.store(fos,"这是一行注释");
        //endregion

        //region 将配置文件读取到properties集合中 利用配置文件的优点在于在不修改代码(通过配置文件)的前提下更改程序
        loadProperties();
        //endregion
    }

    private static void loadProperties() throws Exception{
        FileInputStream fis = new FileInputStream("D:\\IdeaProjects\\JavaPra\\day23\\src\\Demo\\str\\Propertiesload.properties");
        Properties properties1 = new Properties();
        properties1.load(fis);
        Set<String> set = properties1.stringPropertyNames();
        System.out.println("以下遍历从配置文件读取到的键值对");
        for (String s : set) {
            System.out.println(s + "..." + properties1.getProperty(s));
        }
    }
}
```



## 数据结构

### 栈和队列

```java
package note;

import java.util.LinkedList;

public class Stack_queuesNote {//栈和队列
    public static void main(String[] args) {
        LinkedList<String> strings = new LinkedList<>();
        //region 栈：先进后出。push()和pop()方法继承自Deque
        strings.push("one");
        strings.push("two");
        strings.push("three");

        System.out.println(strings.pop());//弹出栈的数据被删除 three
        System.out.println(strings);//[two, one]
        //endregion

        //region 队列：先进先出
        strings.clear();

        //offer()方法和add()方法都是将元素添加到最后，offer()为queue的方法，add()为list方法
        strings.offer("one");//入队列
        strings.offer("two");
        strings.offer("three");
//        strings.add("one");//入队列
//        strings.add("two");
//        strings.add("three");

        System.out.println(strings.poll());//出队列

        System.out.println(strings);//[two, three]
        //endregion
    }
}
```

### 链表

* 单链表

  在每一个节点中，data负责保存数据，而next用于保存下一个节点的地址（引用），这样多个节点就组成了一个链，我们称之为链表。

  ![image-20220216102155956](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216102155956.png)

  

  相较于数组链表在增删数据方面效率要高一些，插入数据时只需要将上一个节点的next执行新节点，新节点的next指向后一个节点。

  ![image-20220216102206870](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216102206870.png)

  

  在删除节点时只需要将前一个节点的next执行要删除节点的后一个节点就行

  ![image-20220216102217765](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216102217765.png)

  但是单链表也有自己的缺点：遍历速度较慢。

  因为单链表不像数组空间是连续的，链表中的节点分散在内存中不同的位置，不管想要得到哪个元素都必须从链表的头节点找起，故而影响到了查询效率。

  

* 双链表(LInkedList为该结构)

  为了解决单链表查询效率较慢的问题，双链表由此诞生。双链表的基本组成单元也是节点，但与单链表节点不同的是双链表的节点多了一个指向前一个节点的引用，因此通过任何一个节点都可以找到其后一个节点及前一个节点，寻找数据时也就不需要非得从头开始。

  多个节点串联在一起就组成了双链表：

  ![image-20220216102235431](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216102235431.png)

### 树

#### 二叉树

![image-20220216103201680](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216103201680.png)

* 左子树：每个节点左边所有的节点
* 右子树：每个节点游遍所有的节点
* 根节点：所有节点的父节点
* 叶子节点：没有子节点的节点

##### 遍历方式

- 先根遍历：先遍历根节点，然后遍历左子树，最后遍历右子树
- 中序遍历：先遍历左子树，然后遍历根节点，最后遍历右子树
- 后序遍历：先遍历左子树，然后遍历右子树，最后遍历根节点

##### 排序二叉树

* 二叉树中左子树上的数据永远比根小，右子树上的数据永远比根大
* ![image-20220216104421406](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216104421406.png)
* 先根遍历 10、6、3、8、12、15
* 中序遍历 3、6、8、10、12、15
* 后序遍历 3、8、6、15、12、10

##### 平衡二叉树

排序二叉树存在的问题：数据倾斜带来遍历效率下降

例如在插入5/6/7/8/9这几个数据时会造成以下问题

如图：

![image-20220216105549230](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105549230.png)

可以看到此时排序二叉树其实已经变成了一个连表，使得遍历的效率大大降低，为了解决这个问题平衡二叉树诞生了。

什么是平衡二叉树：任何节点的左子树与右子树的树高相差不超过1

如图所示就是一颗平衡二叉树，因为树高相差为1

![image-20220216105558854](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105558854.png)

又如

![image-20220216105611806](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105611806.png)

也是一颗平衡二叉树，因为树高相差为1；但下面这棵树就不是平衡二叉树，因为树高相差为2，已经大于1了

![image-20220216105623881](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105623881.png)

平衡二叉树是一种自平衡二叉树，主要是通过数的左旋右旋来实现平衡的

- 左旋：

  ![image-20220216105638889](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105638889.png)

  旋转后的结果为

  ![image-20220216105650386](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105650386.png)

  继续添加8

  ![image-20220216105703990](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105703990.png)

  此时二叉树是平衡的，不会发生旋转

  继续添加9，此时二叉树不平衡，需要发生旋转

  ![image-20220216105713405](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105713405.png)

  得到结果如下

  ![image-20220216105722636](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105722636.png)

  二叉树就变成平衡的了，继续插入10，当插入10时有需要进行旋转，只不过此时不再是围绕着9旋转，因为围绕9旋转的结果并不会让树保持平衡，那么就会再向上寻找一个节点，判断围绕该节点旋转能不能得到平衡，如果可以则围绕着该节点进行旋转。下图所示围绕8旋转之后能得到平衡，将5和6旋转成8的左子树，将7断开与8的连接，然后将7作为6的右子树

  ![image-20220216105739257](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105739257.png)

  ![img](https://img-blog.csdn.net/20140523092135453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

  旋转之后得到的结果是

  ![image-20220216105800173](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105800173.png)



​	继续插入11，此时9的左子树与右子树树高相差超过1不平衡，需要发生旋转

​															![image-20220216105824578](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105824578.png)

​	得到结果如下

​													![image-20220216105836726](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105836726.png)



- 右旋：右旋逻辑跟左旋是一样的，只不过是换了一个方向，此处就不再详细解释了

  

##### 红黑树

![image-20220216111140675](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216111140675.png)

平衡二叉树的缺点：插入数据时经常会频繁的进行左旋、右旋使得数的维护非常麻烦，而且严重消耗性能。

为了减少旋转红黑树诞生了

红黑树在平衡二叉树的基础上为节点增加了颜色，节点的颜色要么是黑色要么是红色，因此称之为红黑树。



红黑树定义和特点

红黑树是一种含有红黑节点并能自平衡的二叉查找树，它必须满足下面要求：

- 每个节点要么是黑色，要么是红色。
- 根节点是黑色。
- 每个叶子节点（NIL）是黑色。
- 每个红色节点的两个子结点一定都是黑色。
- 任意一节点到每个叶子结点的路径都包含数量相同的黑结点。（黑平衡）
- 插入的新节点都是红色

案例：利用红黑树插入5-11之间所有的数

​	插入7时，黑不平衡，发生旋转

![image-20220216105850626](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105850626.png)

​	得到结果如下

![image-20220216105903123](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105903123.png)

​	插入8，将5和7变为黑，达到黑平衡，不需要旋转

![image-20220216105911359](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105911359.png)

​	插入9，黑不平黑发生旋转

![image-20220216105919240](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105919240.png)

​	旋转之后得到

![image-20220216105927356](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105927356.png)

​	插入10，黑平衡，不需要旋转

![image-20220216105932870](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105932870.png)

​	插入11，黑不平衡，需要旋转

![image-20220216105940917](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105940917.png)

​	旋转得到

![image-20220216105949117](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105949117.png)

​	插入12

![image-20220216105958437](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216105958437.png)

​	围绕8进行旋转

![image-20220216110020046](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/image-20220216110020046.png)

### 哈希表

**数组**：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)

**线性链表**：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)

**二叉树**：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。

**哈希表**：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下（后面会探讨下哈希冲突的情况），仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。

数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。

#### 底层实现原理

HashMap底层是由数组、连表/红黑树实现的。

![image-20220127164228812](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/xiangwei/20220127164228.png) 
