const e=JSON.parse('{"key":"v-7c077e6c","path":"/codenotes/javase/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6.html","title":"Java泛型机制","lang":"zh-CN","frontmatter":{"title":"Java泛型机制","icon":"write","category":["Java"],"tag":["Java"],"sticky":false,"star":false,"article":true,"timeline":true,"date":"2022-12-14T00:00:00.000Z","description":"前言 Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。 为什么会引入泛型 泛型的本质是为了...","head":[["meta",{"property":"og:url","content":"https://github.com/noby338/codenotes/javase/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"Noby"}],["meta",{"property":"og:title","content":"Java泛型机制"}],["meta",{"property":"og:description","content":"前言 Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。 为什么会引入泛型 泛型的本质是为了..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-12-14T00:00:00.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"为什么会引入泛型","slug":"为什么会引入泛型","link":"#为什么会引入泛型","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.86,"words":1158},"filePathRelative":"codenotes/javase/Java基础-泛型机制.md","localizedDate":"2022年12月14日"}');export{e as data};
